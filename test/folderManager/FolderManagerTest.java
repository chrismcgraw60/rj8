package folderManager;

import static java.util.stream.Collectors.toSet;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import importer.ReportedTestElement;
import importer.jdbc.BatchJdbcImporter;

import java.nio.file.Path;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Stream;

import javax.sql.DataSource;

import org.junit.BeforeClass;
import org.junit.Test;

import utils.FolderWatchUtils;
import utils.H2DataSource;

import com.google.common.collect.Maps;
import com.jolbox.bonecp.BoneCPDataSource;

import filewatch.ImportFileWatcher;
import folderManager.Folder.Status;

/**
 * Covers usage of {@link ImportFileWatcher} class. Currently 2 cases:
 * <ul>
 * <li> Verify all events are emitted for in bulk creation of a folder tree into the watch folder.
 * <li> Verify all events are emitted and service continues after creation of malformed file within the watch folder.
 * <ul>
 */
public class FolderManagerTest {
		
	private static BoneCPDataSource DS = null;
	
	private static FolderWatchUtils folderUtils = null;
	
	@BeforeClass
	public static void setUp() throws Exception {
		DS = H2DataSource.create();
		H2DataSource.clear(DS);
		
		folderUtils = new FolderWatchUtils(DS);
	}
	
	@Test
	public void clearDB() {}
	
	@Test
	public void testEventsStream_greenPath() throws Exception {

		final IFolderData folderData = new JdbcFolderData(DS);
		final ImportFileWatcher watcher = folderUtils.initialiseWatcher();
		watcher.start();
		final FolderManager folderManager = new FolderManager(watcher, folderData);
		
		/*
		 *  FolderManager notifications run async so we'll use these latches to control the test execution
		 *  - latch1: Will release after all existing folders in storage have been published.
		 *  - latch2: Will release after all new imported folders have been published. 
		 *  If either of the latches time out, we'll fail the test.
		 */
		final CountDownLatch latch1 = new CountDownLatch(1);
		final CountDownLatch latch2 = new CountDownLatch(1);
		/*
		 * Counts the number of times that the FolderManager notifies a Folder event. 
		 */
		final AtomicInteger eventCounter = new AtomicInteger(0);
		
		final int SUB_FOLDER_COUNT = 10;
		final int TEST_FILE_COUNT = 5;
		final int EXPECTED_INITIAL_PUBLISHED_FOLDER_COUNT = SUB_FOLDER_COUNT + 1; // All parent folders + 1 watch folder.
		final int EXPECTED_TOTAL_PUBLISHED_FOLDER_COUNT = EXPECTED_INITIAL_PUBLISHED_FOLDER_COUNT + 2; // All initial folders + 2 in-flight events.
		/*
		 * There is an additional Folder notification for the watch folder as we always insert it into the beginning
		 * of the event stream to indicate it is the root. We don't make any effort to filter it out later.
		 */
		final int EXPECTED_INITIAL_FOLDER_EVENT_COUNT = SUB_FOLDER_COUNT + 2; // All parent folders + 2 watch folder.
		
		/*
		 * Create the test folder structure under the watch root.
		 * We pause here to let the events generated by the creations pass by. The reason we do this is that we 
		 * want to check that these folders will be published by FolderManager, not as the subject of in-flight 
		 * events from the file watcher but rather as folders in storage.
		 */	
		folderUtils.bulkCreationCopyTestFilesTo(watcher.getWatchFolder(), 1, SUB_FOLDER_COUNT, TEST_FILE_COUNT);
		Thread.sleep(5000);
		
		AtomicInteger folderEventCountAtLatch1 = new AtomicInteger(0);
		/*
		 * Set up a subscriber on the watcher to verify the expected events are being triggered.
		 */
		final Map<Path, Folder> publishedFolders = Maps.newHashMap();
		folderManager.folderEventStream().subscribe(publishedFolder -> {
				publishedFolders.put(publishedFolder.getPath(), publishedFolder);
				int evCount = eventCounter.incrementAndGet();
				
				System.out.println(evCount + ": " + publishedFolder.getPath() + "[" + publishedFolder.getStatus() + "]" );
				
				/*
				 * Move past 1st latch when we think we have all the Folder notifications from storage. 
				 */
				if (evCount == EXPECTED_INITIAL_FOLDER_EVENT_COUNT)  {
					System.out.println("============LATCH 1 - ev: " + evCount + "==================");
					folderEventCountAtLatch1.set(publishedFolders.size());
					latch1.countDown(); 
				}
				/*
				 * Move past the 2nd latch when we think we have all the Folder notifications from in-flight 
				 * insertions.
				 */
				if (evCount == EXPECTED_INITIAL_FOLDER_EVENT_COUNT+10)  latch2.countDown(); 
			});
		
		assertTrue("Should pass 1st latch in > 10s.", latch1.await(10, TimeUnit.SECONDS));
		assertTrue("Initial Published Folders should include watch folder.", publishedFolders.containsKey(watcher.getWatchFolder()));
		assertEquals("Should be " + EXPECTED_INITIAL_PUBLISHED_FOLDER_COUNT + " publshed Folders.", EXPECTED_INITIAL_PUBLISHED_FOLDER_COUNT, publishedFolders.size());
						
		/*
		 * Now add some more test files under 2 new folders. We still have an open subscription on the FolderManager's event stream so 
		 * we should see a bunch of notifications corresponding to these folders. 
		 */
		final Set<Path> moreCreatedFiles = folderUtils.bulkCreationCopyTestFilesTo(watcher.getWatchFolder(), SUB_FOLDER_COUNT+1, SUB_FOLDER_COUNT+2, 2);
		final Set<Path> moreCreatedFolders = moreCreatedFiles.stream().map(filePath -> filePath.getParent()).collect(toSet());
		
		assertTrue("Should emit all additional folder events in > 10s.", latch2.await(10, TimeUnit.SECONDS));
		
		publishedFolders.values().forEach(f -> System.out.println(f.getPath()));
		assertEquals("Should have notified us of a total of " + EXPECTED_TOTAL_PUBLISHED_FOLDER_COUNT + " Folders.", EXPECTED_TOTAL_PUBLISHED_FOLDER_COUNT, publishedFolders.size());
		assertEquals("Should have notified us of 2 additional folders.", 2,  moreCreatedFolders.size());
		
		folderManager.shutDown();
	}
	
	@Test
	public void testEventsStream_failureInImport() throws Exception {
		final IFolderData folderData = new JdbcFolderData(DS);
		final ImportFileWatcher watcher = folderUtils.initialiseWatcher(new FailOnImport(DS));
		watcher.start();
		final FolderManager folderManager = new FolderManager(watcher, folderData);
		
		final CountDownLatch latch = new CountDownLatch(1);
		folderManager.folderEventStream().subscribe(publishedFolder -> {
			if (publishedFolder.getStatus() == Status.ActiveWithErrors) {
				latch.countDown();
			}
		});
		
		folderUtils.bulkCreationCopyTestFilesTo(watcher.getWatchFolder(), 1, 2, 1);
		
		assertTrue("Should emit ActiveWithErrors folder event in < 10s.", latch.await(10, TimeUnit.SECONDS));
	}
	
	private static class FailOnImport extends BatchJdbcImporter {
		static final String message = "FAIL ON IMPORT";

		public FailOnImport(DataSource ds) {
			super(ds, new JdbcFolderData(ds), 100);
		}
		
		@Override
		public int doImport(Stream<ReportedTestElement> testCaseEntries) {
			throw new RuntimeException(message);
		}
	}
}
